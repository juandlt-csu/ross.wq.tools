#' @title Integrate field notes with water quality monitoring data
#' @export
#'
#' @description
#' This function merges sensor readings with important field
#' observations about equipment status, maintenance activities, calibration events,
#' and site conditions.
#'
#' The function handles the complexity of matching timestamped field notes to the
#' continuous time series data, ensuring that important information about sensor
#' deployment, maintenance, and observed issues is properly associated with all
#' relevant data points. It also performs forward-filling of certain field attributes
#' to maintain continuity of status information (like deployment status) between
#' field visits.
#'
#' @param df A dataframe containing processed time series data for a single
#' site-parameter combination, typically an element generated by `combine_datasets`.
#'
#' @param notes A dataframe containing processed field notes from mWater, typically
#' the output from `grab_mWater_sensor_notes()`. These notes include information
#' about sensor deployment, maintenance, and observed issues.
#'
#' @return A dataframe containing the original time series data enriched with
#' field note information:
#' - All columns from the original time series data
#' - sonde_employed: Indicator of sensor deployment status
#' - sonde_moved: Indicator of sensor position changes
#' - last_site_visit: Timestamp of most recent site visit
#' - visit_comments: Technician observations during site visits
#' - sensor_malfunction: Noted sensor issues
#' - cals_performed: Calibration events
#'
#' Field status information is forward-filled to maintain continuity between
#' site visits.
#'
#' @examples
#' # Examples are temporarily disabled
#' @seealso [grab_mWater_sensor_notes()]
#' @seealso [tidy_api_data()]
#' @seealso [combine_datasets()]
#' @seealso [generate_summary_statistics()]
#' @seealso [add_field_flag()]

add_field_notes <- function(df, notes) {
  
  # Extract site and parameter information from the input data
  site_arg <- unique(df$site)
  parameter_arg <- unique(df$parameter)
  
  # Filter field notes to include only those relevant to this site
  # This uses a flexible matching approach that handles variations in site naming
  site_field_notes <- notes %>%
    dplyr::filter(grepl(paste(unlist(stringr::str_split(site_arg, " ")), 
                              collapse = "|"), site, ignore.case = TRUE))
  
  # Process the data within a tryCatch to handle potential errors
  tryCatch({
    summary <- df %>%
      # Remove any duplicate records that might have been introduced
      dplyr::distinct() %>%
      
      # Join the time series data with relevant field note information
      # This adds human observations to the sensor readings
      dplyr::full_join(., dplyr::select(site_field_notes, 
                                        sonde_employed, sonde_moved,
                                        last_site_visit, DT_join, visit_comments,
                                        sensor_malfunction, cals_performed),
                       by = c('DT_join')) %>%
      
      # Ensure proper temporal ordering of the combined data
      arrange((DT_join)) %>%
      
      # Ensure timestamps remain in correct datetime format after joining
      dplyr::mutate(DT_round = lubridate::as_datetime(DT_join, tz = "UTC")) %>%
      
      # Set default sonde_employed status (0 = deployed/in water)
      # and forward-fill deployment status and site visit information
      # This maintains status continuity between discrete field observations
      dplyr::mutate(sonde_employed = ifelse(is.na(sonde_employed), 0, sonde_employed)) %>%
      tidyr::fill(c(sonde_employed, last_site_visit, sensor_malfunction)) %>%
      
      # Handle special case: If no site visit information exists at the beginning
      # of the record, assume sonde was not yet deployed (sonde_employed = 1)
      dplyr::mutate(sonde_employed = ifelse(is.na(last_site_visit), 1, sonde_employed)) %>%
      
      # Final cleanup of any duplicates and rows with missing site information
      dplyr::distinct(.keep_all = TRUE) %>%
      dplyr::filter(!is.na(site))
    
    # Return the joined data
    return(summary)
  },
  error = function(e) {
    # Provide informative error message if processing fails
    message("An error occurred with site ", site_arg, " parameter ", parameter_arg)
    message("Error message:", e$message)
    return(NULL) # Return NULL in case of an error
  })
}
